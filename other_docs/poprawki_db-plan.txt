## 1. Lista tabel (kolumny, typy, ograniczenia)

### Typy ENUM (globalnie)

* `user_status`: `INACTIVE`, `ACTIVE`, `BANNED`
* `account_role`: `USER`, `ADMIN`  ✅ **NOWE**
* `publication_kind`: `BOOK`, `MAGAZINE`
* `copy_status`: `AVAILABLE`, `RESERVED`, `LOANED`, `UNAVAILABLE`
* `reservation_status`: `ACTIVE`, `CANCELLED_BY_USER`, `CANCELLED_BY_ADMIN`, `EXPIRED`, `FULFILLED`
* `loan_status`: `ACTIVE`, `RETURNED`
* `message_type`: (np.) `DUE_SOON`, `OVERDUE`, `ACCOUNT_BANNED`, `LOAN_CREATED`
* `operation_action`: wg potrzeb audytu (np. `RESERVE_CREATE`, `RESERVE_CANCEL`, `LOAN_CREATE`, `LOAN_RETURN`, `USER_BAN`, itd.)

---

### 1.1 `users` (ZAKTUALIZOWANE)

**Cel:** czytelnicy + administratorzy. Teraz rozdzielamy:

* `status` = stan konta (ACTIVE/BANNED/INACTIVE),
* `account_role` = uprawnienia funkcjonalne (USER/ADMIN). ✅

Kolumny:

* `id` BIGINT PK, `GENERATED BY DEFAULT AS IDENTITY`
* `first_name` TEXT NOT NULL
* `last_name` TEXT NOT NULL
* `login` CITEXT NOT NULL **UNIQUE**
* `password_hash` TEXT NOT NULL
* `phone` TEXT NOT NULL
* `address` TEXT NOT NULL
* `status` ENUM `user_status` NOT NULL DEFAULT `INACTIVE`
* `account_role` ENUM `account_role` NOT NULL DEFAULT `USER` ✅ **NOWE**
* `created_at` TIMESTAMPTZ NOT NULL DEFAULT now()
* `updated_at` TIMESTAMPTZ NOT NULL DEFAULT now()

**Reguły DB:**

* Trigger blokujący edycję pól innych niż `password_hash` dla nie-admina (jak wcześniej).
* ✅ Trigger blokujący zmianę `account_role` przez nie-admina (oraz blokujący ustawienie `ADMIN` przy rejestracji przez ANON).

**Indeksy dodatkowe (opcjonalne):**

* `users_account_role_idx`: (`account_role`) – tylko jeśli często filtrujesz adminów.

---

### 1.2 `category`

(bez zmian)

### 1.3 `publication`

(bez zmian)

### 1.4 `authors`

(bez zmian)

### 1.5 `publication_authors`

(bez zmian)

### 1.6 `inventory_counter`

(bez zmian)

### 1.7 `copy`

(bez zmian)

### 1.8 `reservation`

(bez zmian)

### 1.9 `loan`

(bez zmian)

### 1.10 `message`

(bez zmian)

### 1.11 `login_log`

(bez zmian)

### 1.12 `operation_history`

(bez zmian)

### 1.13 `library_info`

(bez zmian)

---

## 2. Relacje między tabelami

**Bez zmian** (dodanie `users.account_role` nie zmienia relacji).

---

## 3. Indeksy

**Bez zmian** + (opcjonalnie) `users_account_role_idx` jak wyżej.

---

## 4. Zasady PostgreSQL RLS (Row Level Security) — ZAKTUALIZOWANE POD ADMINA

### 4.1 Kontekst aplikacji (bez zmian)

Aplikacja ustawia per transakcję:

* `SET LOCAL app.user_id = '<bigint>'`
* `SET LOCAL app.role = '<ANON|USER_INACTIVE|USER_ACTIVE|USER_BANNED|ADMIN>'`

### 4.2 Funkcje pomocnicze (zalecane) — weryfikacja admina w DB ✅

Żeby nie opierać się wyłącznie na “deklaracji” `app.role`, polityki powinny używać funkcji, która **potwierdza admina w tabeli `users`**:

* `app_current_user_id()` → BIGINT (z `current_setting('app.user_id', true)`)
* `app_current_role()` → TEXT (z `current_setting('app.role', true)`)
* ✅ `app_is_admin()` → BOOLEAN, które zwraca TRUE tylko jeśli:

  * `app_current_role() = 'ADMIN'`
  * **i** `users.id = app_current_user_id()` ma `account_role = 'ADMIN'`

> Najlepiej zrobić `app_is_admin()` jako `SECURITY DEFINER`, żeby mogła odczytać `users.account_role` niezależnie od RLS.

### 4.3 RLS – tabele (zmiany w warunkach “admin”)

Wszystkie miejsca, gdzie wcześniej było “`app.role = 'ADMIN'`”, zamień na **`app_is_admin()`**.

#### `publication`, `copy`, `category`, `authors`, `publication_authors`

* SELECT: dozwolone gdy `app_current_role() IN ('USER_ACTIVE') OR app_is_admin()`
* INSERT/UPDATE/DELETE: tylko `app_is_admin()`

#### `users` (ZAKTUALIZOWANE)

* SELECT:

  * `app_is_admin()` → wszystkie
  * w przeciwnym razie → tylko `id = app_current_user_id()`
* INSERT:

  * `ANON` (rejestracja): dozwolone, ale **WITH CHECK** wymusza:

    * `account_role = 'USER'`
    * `status = 'INACTIVE'` (lub dopuszczasz tylko INACTIVE na starcie)
* UPDATE:

  * `app_is_admin()` → wszystko
  * user → tylko własny rekord i tylko `password_hash`
  * dodatkowo trigger: **nie-admin nie może zmienić `account_role` ani danych profilu**
* DELETE: tylko `app_is_admin()` (opcjonalnie)

#### `reservation`

* ADMIN: `app_is_admin()` – wszystkie operacje
* USER_ACTIVE: tylko własne (INSERT/SELECT/UPDATE zgodnie z wcześniejszymi zasadami)
* USER_BANNED/ANON/USER_INACTIVE: brak

#### `loan`

* SELECT:

  * `app_is_admin()` → wszystkie
  * `USER_ACTIVE` → własne
  * `USER_BANNED` → własne (tylko podgląd)
* INSERT/UPDATE: tylko `app_is_admin()`

#### `message`

* ADMIN: `app_is_admin()` – pełny dostęp
* USER_ACTIVE (i opcjonalnie USER_BANNED): tylko własne; update read/hidden z CHECK “hidden tylko gdy read”

#### `login_log`, `operation_history`

* `login_log`: INSERT dozwolony (logowanie), SELECT tylko `app_is_admin()`
* `operation_history`: INSERT/SELECT tylko `app_is_admin()`

#### `library_info`

* publiczny SELECT (bez RLS lub `USING (true)`)

---

## 5. Dodatkowe uwagi / decyzje projektowe — DOPISEK

### 5.1 Skąd aplikacja “wie” czy Jan Kowalski jest adminem?

* Aplikacja czyta z DB `users.account_role`.
* Na tej podstawie ustawia `SET LOCAL app.role = 'ADMIN'` lub jedną z ról użytkownika (`USER_ACTIVE`, `USER_BANNED`, itd.).
* DB **weryfikuje** admina przez `app_is_admin()`, więc nawet jeśli ktoś spróbuje “wstrzyknąć” `app.role='ADMIN'`, RLS nie przepuści bez `account_role='ADMIN'` w `users`.

### 5.2 Kto może nadawać admina?

* Tylko admin (wymuszone przez RLS + trigger blokujący zmianę `account_role` dla nie-admina).
* Rejestracja (`ANON`) zawsze tworzy `account_role='USER'`.

---
